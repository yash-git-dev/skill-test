package pdf

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"student-report-service/internal/config"
	"student-report-service/internal/models"

	"github.com/jung-kurt/gofpdf"
)

// Generator handles PDF report generation
type Generator struct {
	config    *config.ReportConfig
	outputDir string
}

// NewGenerator creates a new PDF generator
func NewGenerator(cfg *config.ReportConfig) (*Generator, error) {
	if cfg == nil {
		return nil, fmt.Errorf("config cannot be nil")
	}

	// Ensure output directory exists
	if err := os.MkdirAll(cfg.OutputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	return &Generator{
		config:    cfg,
		outputDir: cfg.OutputDir,
	}, nil
}

// GenerateStudentReport generates a comprehensive PDF report for a student
func (g *Generator) GenerateStudentReport(student *models.Student, metadata *models.ReportMetadata) (string, error) {
	if student == nil {
		return "", fmt.Errorf("student cannot be nil")
	}

	if metadata == nil {
		metadata = &models.ReportMetadata{
			GeneratedAt: time.Now(),
			GeneratedBy: "System",
			ReportID:    fmt.Sprintf("RPT-%d-%d", student.ID, time.Now().Unix()),
		}
	}

	// Create PDF instance
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetMargins(20, 20, 20)
	pdf.SetAutoPageBreak(true, 20)

	// Add page
	pdf.AddPage()

	// Generate the report content
	g.addHeader(pdf, metadata)
	g.addStudentBasicInfo(pdf, student)
	g.addContactDetails(pdf, student)
	g.addFamilyInformation(pdf, student)
	g.addAddressInformation(pdf, student)
	g.addAcademicInformation(pdf, student)
	g.addFooter(pdf, metadata)

	// Generate filename
	sanitizedName := g.sanitizeFilename(student.FormatName())
	filename := fmt.Sprintf("student_report_%d_%s_%s.pdf",
		student.ID,
		sanitizedName,
		time.Now().Format("20060102_150405"))

	filepath := filepath.Join(g.outputDir, filename)

	// Save the PDF
	if err := pdf.OutputFileAndClose(filepath); err != nil {
		return "", fmt.Errorf("failed to save PDF: %w", err)
	}

	// Check file size
	if fileInfo, err := os.Stat(filepath); err == nil {
		if fileInfo.Size() > g.config.MaxFileSize {
			os.Remove(filepath) // Clean up oversized file
			return "", fmt.Errorf("generated PDF exceeds maximum file size limit")
		}
	}

	return filepath, nil
}

// addHeader adds the report header with title and metadata
func (g *Generator) addHeader(pdf *gofpdf.Fpdf, metadata *models.ReportMetadata) {
	// Title
	pdf.SetFont("Arial", "B", 20)
	pdf.SetTextColor(0, 51, 102) // Dark blue
	pdf.CellFormat(0, 15, "Student Information Report", "", 1, "C", false, 0, "")
	pdf.Ln(5)

	// Metadata section
	pdf.SetFont("Arial", "", 10)
	pdf.SetTextColor(100, 100, 100) // Gray

	// Report details
	pdf.CellFormat(0, 5, fmt.Sprintf("Report ID: %s", metadata.ReportID), "", 1, "R", false, 0, "")
	pdf.CellFormat(0, 5, fmt.Sprintf("Generated: %s", metadata.GeneratedAt.Format("January 2, 2006 at 15:04 MST")), "", 1, "R", false, 0, "")
	pdf.CellFormat(0, 5, fmt.Sprintf("Generated by: %s", metadata.GeneratedBy), "", 1, "R", false, 0, "")

	pdf.Ln(10)

	// Add watermark
	if g.config.WatermarkText != "" {
		g.addWatermark(pdf, g.config.WatermarkText)
	}
}

// addStudentBasicInfo adds basic student information section
func (g *Generator) addStudentBasicInfo(pdf *gofpdf.Fpdf, student *models.Student) {
	g.addSectionHeader(pdf, "Basic Information")

	// Basic info table
	g.addInfoRow(pdf, "Student ID:", fmt.Sprintf("%d", student.ID))
	g.addInfoRow(pdf, "Full Name:", student.FormatName())
	g.addInfoRow(pdf, "Email Address:", student.FormatEmail())
	g.addInfoRow(pdf, "System Access:", g.formatBool(student.SystemAccess))

	if student.Gender != nil {
		g.addInfoRow(pdf, "Gender:", models.SafeString(student.Gender, "Not specified"))
	}

	if student.DOB != nil {
		g.addInfoRow(pdf, "Date of Birth:", models.SafeString(student.DOB, "Not specified"))
	}

	if student.Phone != nil {
		g.addInfoRow(pdf, "Phone Number:", models.SafeString(student.Phone, "Not provided"))
	}

	pdf.Ln(5)
}

// addContactDetails adds contact information section
func (g *Generator) addContactDetails(pdf *gofpdf.Fpdf, student *models.Student) {
	g.addSectionHeader(pdf, "Contact Information")

	g.addInfoRow(pdf, "Primary Email:", student.FormatEmail())
	g.addInfoRow(pdf, "Phone Number:", models.SafeString(student.Phone, "Not provided"))

	pdf.Ln(5)
}

// addFamilyInformation adds family and guardian information
func (g *Generator) addFamilyInformation(pdf *gofpdf.Fpdf, student *models.Student) {
	g.addSectionHeader(pdf, "Family & Guardian Information")

	// Father's information
	g.addSubsectionHeader(pdf, "Father's Information")
	g.addInfoRow(pdf, "Father's Name:", models.SafeString(student.FatherName, "Not provided"))
	g.addInfoRow(pdf, "Father's Phone:", models.SafeString(student.FatherPhone, "Not provided"))

	pdf.Ln(3)

	// Mother's information
	g.addSubsectionHeader(pdf, "Mother's Information")
	g.addInfoRow(pdf, "Mother's Name:", models.SafeString(student.MotherName, "Not provided"))
	g.addInfoRow(pdf, "Mother's Phone:", models.SafeString(student.MotherPhone, "Not provided"))

	pdf.Ln(3)

	// Guardian information
	g.addSubsectionHeader(pdf, "Guardian Information")
	g.addInfoRow(pdf, "Guardian's Name:", models.SafeString(student.GuardianName, "Not provided"))
	g.addInfoRow(pdf, "Guardian's Phone:", models.SafeString(student.GuardianPhone, "Not provided"))
	g.addInfoRow(pdf, "Relation to Student:", models.SafeString(student.RelationOfGuardian, "Not specified"))

	pdf.Ln(5)
}

// addAddressInformation adds address information
func (g *Generator) addAddressInformation(pdf *gofpdf.Fpdf, student *models.Student) {
	g.addSectionHeader(pdf, "Address Information")

	g.addInfoRow(pdf, "Current Address:", models.SafeString(student.CurrentAddress, "Not provided"))
	g.addInfoRow(pdf, "Permanent Address:", models.SafeString(student.PermanentAddress, "Not provided"))

	pdf.Ln(5)
}

// addAcademicInformation adds academic information
func (g *Generator) addAcademicInformation(pdf *gofpdf.Fpdf, student *models.Student) {
	g.addSectionHeader(pdf, "Academic Information")

	g.addInfoRow(pdf, "Class:", models.SafeString(student.Class, "Not assigned"))
	g.addInfoRow(pdf, "Section:", models.SafeString(student.Section, "Not assigned"))

	if student.Roll != nil {
		g.addInfoRow(pdf, "Roll Number:", fmt.Sprintf("%d", models.SafeInt(student.Roll, 0)))
	} else {
		g.addInfoRow(pdf, "Roll Number:", "Not assigned")
	}

	g.addInfoRow(pdf, "Admission Date:", models.SafeString(student.AdmissionDate, "Not recorded"))

	if student.ReporterName != nil {
		g.addInfoRow(pdf, "Reporter:", models.SafeString(student.ReporterName, "System"))
	}

	pdf.Ln(5)
}

// addFooter adds the report footer
func (g *Generator) addFooter(pdf *gofpdf.Fpdf, metadata *models.ReportMetadata) {
	pdf.SetY(-30)
	pdf.SetFont("Arial", "I", 8)
	pdf.SetTextColor(150, 150, 150)

	pdf.CellFormat(0, 5, "This report is confidential and intended for authorized personnel only.", "", 1, "C", false, 0, "")
	pdf.CellFormat(0, 5, fmt.Sprintf("Generated on %s", metadata.GeneratedAt.Format("January 2, 2006")), "", 1, "C", false, 0, "")
	pdf.CellFormat(0, 5, "Student Management System", "", 1, "C", false, 0, "")
}

// Helper methods for consistent formatting

func (g *Generator) addSectionHeader(pdf *gofpdf.Fpdf, title string) {
	pdf.SetFont("Arial", "B", 14)
	pdf.SetTextColor(0, 51, 102)
	pdf.CellFormat(0, 8, title, "", 1, "L", false, 0, "")
	pdf.Ln(2)
}

func (g *Generator) addSubsectionHeader(pdf *gofpdf.Fpdf, title string) {
	pdf.SetFont("Arial", "B", 11)
	pdf.SetTextColor(51, 51, 51)
	pdf.CellFormat(0, 6, title, "", 1, "L", false, 0, "")
}

func (g *Generator) addInfoRow(pdf *gofpdf.Fpdf, label, value string) {
	pdf.SetFont("Arial", "B", 10)
	pdf.SetTextColor(0, 0, 0)
	pdf.CellFormat(50, 6, label, "", 0, "L", false, 0, "")

	pdf.SetFont("Arial", "", 10)
	pdf.SetTextColor(51, 51, 51)
	pdf.CellFormat(0, 6, value, "", 1, "L", false, 0, "")
}

func (g *Generator) addWatermark(pdf *gofpdf.Fpdf, text string) {
	pdf.SetFont("Arial", "", 50)
	pdf.SetTextColor(240, 240, 240) // Very light gray

	// Rotate and add watermark text
	pdf.TransformBegin()
	pdf.TransformRotate(45, 105, 148) // Rotate 45 degrees at center of page
	pdf.Text(20, 100, text)
	pdf.TransformEnd()
}

func (g *Generator) formatBool(value bool) string {
	if value {
		return "Enabled"
	}
	return "Disabled"
}

func (g *Generator) sanitizeFilename(name string) string {
	// Replace invalid characters with underscores
	invalidChars := []string{"/", "\\", ":", "*", "?", "\"", "<", ">", "|", " "}
	result := name
	for _, char := range invalidChars {
		result = strings.ReplaceAll(result, char, "_")
	}

	// Limit length
	if len(result) > 30 {
		result = result[:30]
	}

	return result
}

// CleanupOldReports removes old report files based on configuration
func (g *Generator) CleanupOldReports() error {
	if !g.config.Cleanup {
		return nil
	}

	return filepath.Walk(g.outputDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(info.Name(), ".pdf") {
			if time.Since(info.ModTime()) > g.config.CleanupAfter {
				return os.Remove(path)
			}
		}
		return nil
	})
}
